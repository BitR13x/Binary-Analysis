import re
from typing import Dict, List, Any, Set
import subprocess
import tempfile
import os

class VulnerabilityDetector:
    def __init__(self):
        # Define vulnerable functions with their risk levels
        self.vulnerable_functions = {
            'critical': [
                'gets', 'scanf', 'vscanf', 'sprintf', 'vsprintf',
                'strcpy', 'strcat', 'system', 'exec', 'popen'
            ],
            'high': [
                'strncpy', 'strncat', 'snprintf', 'vsnprintf',
                'memcpy', 'memmove', 'bcopy', 'bzero'
            ],
            'medium': [
                'strlen', 'strcmp', 'strncmp', 'strchr', 'strstr',
                'malloc', 'calloc', 'realloc', 'free', 'alloca'
            ],
            'low': [
                'printf', 'fprintf', 'fopen', 'fclose', 'fread', 'fwrite'
            ]
        }
        
        # Common vulnerability patterns
        self.vulnerability_patterns = {
            'format_string': [
                r'printf\s*\(\s*[^"]*\)',
                r'fprintf\s*\(\s*[^,]*,\s*[^"]*\)',
                r'sprintf\s*\(\s*[^,]*,\s*[^"]*\)'
            ],
            'buffer_overflow': [
                r'gets\s*\(',
                r'strcpy\s*\(',
                r'strcat\s*\(',
                r'scanf\s*\([^"]*%s'
            ],
            'integer_overflow': [
                r'malloc\s*\(\s*.*\*.*\)',
                r'calloc\s*\(\s*.*,.*\*.*\)',
                r'realloc\s*\(\s*.*,.*\*.*\)'
            ],
            'command_injection': [
                r'system\s*\(',
                r'exec\w*\s*\(',
                r'popen\s*\('
            ]
        }
    
    def analyze_vulnerabilities(self, file_path: str, strings: List[str]) -> Dict[str, Any]:
        """Main vulnerability analysis function"""
        try:
            results = {
                'vulnerable_functions': self._detect_vulnerable_functions(strings),
                'vulnerability_patterns': self._detect_vulnerability_patterns(strings),
                'risk_assessment': {},
                'recommendations': [],
                'severity_score': 0
            }
            
            # Calculate risk assessment
            results['risk_assessment'] = self._calculate_risk_assessment(results)
            results['severity_score'] = self._calculate_severity_score(results)
            results['recommendations'] = self._generate_recommendations(results)
            
            return results
            
        except Exception as e:
            return {'error': f"Vulnerability analysis failed: {str(e)}"}
    
    def _detect_vulnerable_functions(self, strings: List[str]) -> Dict[str, List[str]]:
        """Detect vulnerable functions in the binary strings"""
        found_functions = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        # Create a set of all strings for faster lookup
        string_set = set(strings)
        
        for severity, functions in self.vulnerable_functions.items():
            for func in functions:
                # Look for the function name in various forms
                patterns = [
                    func,  # Direct match
                    f"_{func}",  # With underscore prefix
                    f"{func}@",  # With @ suffix (common in binaries)
                    f"__{func}",  # With double underscore
                ]
                
                for pattern in patterns:
                    for string in strings:
                        if pattern in string:
                            if func not in found_functions[severity]:
                                found_functions[severity].append(func)
                            break
        
        return found_functions
    
    def _detect_vulnerability_patterns(self, strings: List[str]) -> Dict[str, List[str]]:
        """Detect vulnerability patterns in strings"""
        found_patterns = {}
        
        # Combine all strings into one large string for pattern matching
        combined_strings = '\n'.join(strings)
        
        for vuln_type, patterns in self.vulnerability_patterns.items():
            found_patterns[vuln_type] = []
            
            for pattern in patterns:
                matches = re.findall(pattern, combined_strings, re.IGNORECASE)
                if matches:
                    found_patterns[vuln_type].extend(matches)
        
        # Remove empty categories
        found_patterns = {k: v for k, v in found_patterns.items() if v}
        
        return found_patterns
    
    def _calculate_risk_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate overall risk assessment"""
        vulnerable_functions = results.get('vulnerable_functions', {})
        vulnerability_patterns = results.get('vulnerability_patterns', {})
        
        risk_factors = {
            'critical_functions': len(vulnerable_functions.get('critical', [])),
            'high_functions': len(vulnerable_functions.get('high', [])),
            'medium_functions': len(vulnerable_functions.get('medium', [])),
            'low_functions': len(vulnerable_functions.get('low', [])),
            'pattern_matches': len(vulnerability_patterns)
        }
        
        # Calculate overall risk level
        total_critical = risk_factors['critical_functions']
        total_high = risk_factors['high_functions']
        total_medium = risk_factors['medium_functions']
        
        if total_critical > 3:
            risk_level = 'CRITICAL'
        elif total_critical > 0 or total_high > 5:
            risk_level = 'HIGH'
        elif total_high > 0 or total_medium > 10:
            risk_level = 'MEDIUM'
        elif total_medium > 0:
            risk_level = 'LOW'
        else:
            risk_level = 'MINIMAL'
        
        return {
            'risk_level': risk_level,
            'risk_factors': risk_factors,
            'total_vulnerabilities': sum(risk_factors.values())
        }
    
    def _calculate_severity_score(self, results: Dict[str, Any]) -> int:
        """Calculate numerical severity score (0-100)"""
        vulnerable_functions = results.get('vulnerable_functions', {})
        vulnerability_patterns = results.get('vulnerability_patterns', {})
        
        score = 0
        
        # Score based on vulnerable functions
        score += len(vulnerable_functions.get('critical', [])) * 25
        score += len(vulnerable_functions.get('high', [])) * 15
        score += len(vulnerable_functions.get('medium', [])) * 8
        score += len(vulnerable_functions.get('low', [])) * 3
        
        # Score based on vulnerability patterns
        score += len(vulnerability_patterns) * 10
        
        # Cap at 100
        return min(score, 100)
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = []
        vulnerable_functions = results.get('vulnerable_functions', {})
        vulnerability_patterns = results.get('vulnerability_patterns', {})
        risk_level = results.get('risk_assessment', {}).get('risk_level', 'UNKNOWN')
        
        # General recommendations based on risk level
        if risk_level in ['CRITICAL', 'HIGH']:
            recommendations.append("ðŸš¨ URGENT: This binary contains critical security vulnerabilities that require immediate attention")
            recommendations.append("Consider conducting a thorough code review and security audit")
            recommendations.append("Implement input validation and bounds checking")
        
        # Specific recommendations based on vulnerable functions
        if vulnerable_functions.get('critical'):
            critical_funcs = vulnerable_functions['critical']
            if 'gets' in critical_funcs:
                recommendations.append("Replace gets() with fgets() to prevent buffer overflows")
            if 'strcpy' in critical_funcs or 'strcat' in critical_funcs:
                recommendations.append("Replace strcpy/strcat with strncpy/strncat or use safer alternatives")
            if 'sprintf' in critical_funcs:
                recommendations.append("Replace sprintf with snprintf to prevent buffer overflows")
            if 'system' in critical_funcs:
                recommendations.append("Avoid system() calls; use exec family functions with proper validation")
        
        # Pattern-based recommendations
        if 'format_string' in vulnerability_patterns:
            recommendations.append("Fix format string vulnerabilities by using proper format specifiers")
        if 'buffer_overflow' in vulnerability_patterns:
            recommendations.append("Implement proper buffer size checking and bounds validation")
        if 'command_injection' in vulnerability_patterns:
            recommendations.append("Sanitize all user inputs before executing system commands")
        
        # General security recommendations
        recommendations.extend([
            "Enable compiler security features (stack canaries, ASLR, NX bit)",
            "Use static analysis tools during development",
            "Implement comprehensive input validation",
            "Consider using memory-safe programming languages for critical components"
        ])
        
        return recommendations[:10]  # Limit to top 10 recommendations
    
    def get_vulnerability_details(self, vuln_name: str) -> Dict[str, str]:
        """Get detailed information about a specific vulnerability"""
        vulnerability_info = {
            'gets': {
                'description': 'Reads input without bounds checking, leading to buffer overflow',
                'impact': 'Code execution, denial of service',
                'mitigation': 'Use fgets() instead'
            },
            'strcpy': {
                'description': 'Copies strings without length checking',
                'impact': 'Buffer overflow, memory corruption',
                'mitigation': 'Use strncpy() or strlcpy()'
            },
            'sprintf': {
                'description': 'Formats strings without bounds checking',
                'impact': 'Buffer overflow, format string attacks',
                'mitigation': 'Use snprintf() with proper buffer size'
            },
            'system': {
                'description': 'Executes shell commands, vulnerable to injection',
                'impact': 'Command injection, privilege escalation',
                'mitigation': 'Use exec family functions with validation'
            },
            'scanf': {
                'description': 'Reads formatted input without bounds checking',
                'impact': 'Buffer overflow, format string attacks',
                'mitigation': 'Specify field width or use fgets() with sscanf()'
            }
        }
        
        return vulnerability_info.get(vuln_name, {
            'description': 'Potentially unsafe function',
            'impact': 'Various security implications',
            'mitigation': 'Review usage and consider safer alternatives'
        })
